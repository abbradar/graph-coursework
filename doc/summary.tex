\documentclass[a4paper,12pt]{report}

\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{ifpdf}
\usepackage{fancyhdr}
\usepackage{minitoc}

\ifpdf
  \usepackage{cmap}
\fi

\usepackage[T2A]{fontenc}

\title{Расчётно-пояснительная записка по курсовой "Машинная графика"}
\author{Николай Амиантов}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\renewcommand{\thesection}{\arabic{section}}
\setcounter{secnumdepth}{3}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyfoot[C]{\thepage}
\fancyfoot[R]{\thedate}

\begin{document}

% TODO Поправить титульник чтобы был как по ГОСТу потом
\maketitle

\section{Введение}

Задача отрисовки трёхмерных сцен для игровых продуктов весьма актуальна в настоящее время. На рынке присутствует огромное количество игровых продуктов, существует отдельная индустрия с большим оборотом, которая удовлетворяет спрос потребителя на качественные и хорошо проработанные видеоигры. Одним из важных элементов игры является качество её графики и скорость её работы, что позволяет, с одной стороны, предложить потребителю более красивый и детальный игровой мир, а с другой --- увеличить рынок сбыта за счёт поддержки большего количества устройств. Соответственно, актуальны задачи отрисовки сложных трёхмерных сцен со множеством динамических объектов. \\
Цель работы - разработка игры--детского конструктора. В рамках данной работы я изучил алгоритмы и структуры данных, используемые в процессах отрисовки трёхмерных сцен.
% TODO Немного дополнить

\section{Аналитический раздел}
% IDEA Для каждого места где рассматриваются альтернативы сделать сначала обзор всех вариантов, а потом выбор и доводы, как в разделе про формат хранения

\subsection{Схожие продукты}
Продукт схож с играми-"песочницами", в которых игроку предоставляется мир и правила игры, но нет чётко определённых целей и методов их достижения. Наиболее схожей с продуктом по идее (хотя гораздо сложнее) является игра Garry's Mod, которая предоставляет пользователю трёхмерный мир-карту и возможность загружать и располагать на ней любые заранее определённые объекты, менять их расположение, физические свойства, иногда размеры и внешний вид, а также соединять их друг с другом разнообразными способами. В игре реализована достаточно реалистичная физика, и основная её идея --- построение произвольных механизмов и конструкций из набора объектов. Многие идеи из неё были взяты в основу продукта, например, камера от первого лица, набор инструментов, меню для работы с объектами и прочее.

\subsection{Алгоритмы хранения}
Хранить объекты в памяти можно хранить несколькими способами, в частности:
\begin{itemize}
\item Как наборы многоугольников с координатами точек. \\
Просто, занимает много памяти из-за повторений точек.
\item Как набор точек и многоугольники в виде наборов индексов в массиве точек. \\
Гораздо экономичнее, незначительная потеря скорости из-за необходимости разыменования, без потерь читаемости.
\end{itemize}
Был выбран второй способ как гораздо более экономичный по памяти при почти отсутствующих потерях скорости.

\subsection{Многоугольники}
Можно описывать модель используя различные виды многоугольников:
\begin{itemize}
\item С динамическим количеством вершин. \\
Медленно из-за наличия динамической структуры данных.
\item С фиксированным количеством вершин. \\
Незначительно менее гибко, гораздо быстрее из-за отсутствия динамических структур данных.
\end{itemize}
Был выбран второй вид как дающий значительный прирост скорости. Потеря гибкости незначительная --- редкие модели можно представить в виде наборов многоугольников с большим количеством сторон. Более того, многие модели являются аппроксимациями реальных объектов, а при аппроксимации большое количество сторон не имеет смысла, поскольку обычно в таких моделях часто отсутствуют достаточно ровные стороны. С другой стороны, многоугольник с меньшим количеством вершин можно представить как многоугольник с большим их количеством, в котором несколько точек последовательно совпадают. \\
Также необходимо было выбрать количество сторон у многоугольников для хранения. Было выбрано хранить треугольники по следующим причинам. Во-первых, наличие многоугольников с динамическим количеством частей замедляет отрисовку и не даёт больших преимуществ кроме удобства задания модели. Во-вторых, треугольник --- самый простой из возможных многоугольников. С одной стороны, использование треугольников даёт возможность проводить некоторые специфические оптимизации, например, при отрисовке. С треугольниками легко работать, поскольку невозможно задать треугольник неверно (точки всегда будут лежать на одной плоскости). Большинство трёхмерных редакторов экспортируют модели как набор треугольников, и API видеоускорения DirectX и OpenGL работают именно с ними (и преобразовывают многоугольники в треугольники). Хотя наличие большего числа сторон может дать большую скорость отрисовки для моделей в которых сразу большие стороны представлены одним многоугольником, по моему мнению это несколько спорно из-за добавления многих нюансов, треугольники же просты и универсальны. Также, работая с треугольниками мы лишаем себя проблем по обнаружению и работе с невыпуклыми многоугольниками, что обычно требует относительно больших затрат ресурсов при отсечении.
% IDEA Можно попробовать построить исследование разницы в скорости для разных видов многоугольников.

\subsection{Хранение в памяти}
Объект в памяти хранится как два массива --- точек и индексов. Структура данных "массив" была выбрана, поскольку обеспечивает компактность и более быстрый обход по сравнению со связанным списком, что важно для данной задачи. С другой стороны, создание такого массива будет происходить лишь единожды, на этапе чтения объекта из файла данных, поэтому скорость добавления и удаления элементов практически не имеет значения. \\
Объекты хранятся на сцене в виде связанного списка. Этот способ был выбран так как предполагается частое добавление и удаление объектов со сцены, объектов на сцене на порядок меньше относительно данных всех объектов, связанный список даёт удовлетворительную скорость обхода и небольшое количество данных для поддержания структуры. \\
Были рассмотрены различные виды октодеревьев для хранения объектов. Эти структуры данных дают возможность быстро выстраивать объекты по глубине, оценивать расстояния и делать другие важные для ускорения отрисовки операции. Однако, эти структуры предполагают относительную статичность положения объектов, и при изменении координат одного объекта обычно приходится перестраивать всё дерево, что неприемлемо для нашей задачи.
% IDEA Можно подробнее изучить такие структуры данных

\subsection{Преобразования координат}
Преобразования координат можно представить в виде операций над матрицами и векторами или операций над кватернионами. Для преобразований координат используются матрицы и операции перемножения их между собой и умножения их на вектора. Это даёт возможность описать практически любое необходимое преобразование матрицей. Исключение составило перспективное преобразование, т.к. в процессе дальшейшей отрисовки используются величины глубины каждой точки, которые оказалось невозможно сохранить при описании преобразования матрицей. В процессе работы рендерера вычисляется матрица преобразования по которой все точки объекта приводятся в систему координат камеры, затем они отдельно преобразовываются согласно перспективе (удалению от наблюдателя).
% TODO Точно никак матрицей перспективное преобразование не описать?

\subsection{Отсечение}
После преобразования все треугольники отсекаются по плоскости $Z_0$ и плоскостям, ограничивающим видовой экран. Треугольники обладают фиксированным числом вершин и вариантом разбиений (0, 1 или 2 треугольника в результате), причём в большинстве случаем отсечение по всем плоскостям будет целиком оставлять треугольник без изменений или отсекать его целиком (пользователь будет обычно смотреть на объект целиком). Было рассмотрено несколько вариантов реализации и выбран самый простой --- треугольники отсекаются по одному по каждой плоскости в отдельности с помощью поиска пересечений сторон треугольника с плоскостью, причём каждое отсечение может вернуть 0, 1 или 2 треугольника. Если обнаружено что треугольник не разбивался и был полностью отсечён очередной плоскостью, работа останавливается. Эта реализация, по моему мнению, самая простая и быстрая для такой задачи, поскольку у нас отсутствуют невыпуклые многоугольники и плоскости перпендикулярны координатным осям. Альтернативами являются алгоритмы отсечения многоугольников многоугольниками наподобие алгоритма Уайлера--Азертона (сложны и неоправданы для нашей задачи, а также хуже по скорости и количеству потребляемой памяти из-за общности) и, возможно, алгоритм Коэна--Сазерленда (может быть использован для отсечения по видовой рамке, но достоинства сомнительны по сравнению с отсечением по одной плоскости из-за сложности нахождения треугольника результата, т.к. алгоритм расчитан для отсечения отрезков).

\subsection{Отсечение невидимых поверхностей}
Для отсечения невидимых поверхностей был выбран один из самых быстрых и простых алгоритмов --- Z-буфер. С одной стороны, он обеспечивает достаточно большую скорость, причём большое время занимает заполнение буфера начальными значениями. Он занимает относительно много памяти, но это не является большим недостатком для настоящего времени --- буфер типа float размера 640*480 занимает 1200 КиБ --- небольшой объем по сравнению с современными объёмами ОЗУ. Он также обеспечивает большую универсальность и независимость от типа и формата модели, скажем, не требует усложнения в случае невыпуклых моделей. Альтернативой является, например, алгоритм Робертса, однако он относительно сложен в реализации и скорее даёт упадок, чем прирост скорости, по сравнению с Z-буфером.
% TODO Проверить насчёт алгоритма Робертса

\subsection{Заливка}
Для заливки существует несколько возможных алгоритмов. Нас интересуют в первую очередь алгоритмы заливки векторно заданных фигур, поскольку универсальные алгоритмы (затравочный алгоритм) дают гораздо меньшую скорость заливки. Из них наиболее привлекательным по скорости является алгоритм списка активных рёбер (САР), самый быстрый из подобных алгоритмов по результатам измерений. Также его плюсом является то что установка точки на нужный цвет происходит только один раз для каждого треугольника, что оптимально для работы с z-буфером. Альтернативами являлись алгоритм с флагом, алгоритм заполнения и разнообразные его модификации.

\section{Технологический раздел}

\subsection{Язык программирования}
Для разработки был выбран язык программирования C++. Из его достоинств следует выделить высокую скорость (практически сравнимую с языком C для современных компиляторов) и широкие возможности, позволяющие достаточно писать достаточно удобный и выразительный код по сравнению с тем же C, а так же вероятно самое большое количество удобных сторонних библиотек на все случаи жизни. Из недостатков следует выделить сложность синтаксиса и большое количество правил языка и большое количество нетривиальных моментов в языке, из-за чего следует потенциально большое количество скрытых ошибок.

\subsection{Основная библиотека}
Были рассмотрены несколько вариантов фреймворков и библиотек, на которых предполагалось осуществлять проект. В итоге, была выбрана библиотека SDL, которая предоставляет кроссплатформенный набор инструментов для создания окна, поверхности для рисования, перехват событий клавиатуры и мыши, таймеры, потоки, чтение файлов и прочее. Библиотека специально разработана для нужд программистов игр и расчитана на её применение для работы с OpenGL, но включает в себя отличные средства работы с двухмерными поверхностями в виде массивов точек с методами для слияния поверхностей, изменения и отображения. Всё это производится максимально быстро и с использованием видеокарты там где это возможно (скажем, поверхности можно смешивать аппаратно). Использованные средства:
\begin{itemize}
\item Создание и отображение окна
\item Загрузка файлов, в частности шрифтов
\item Рендеринг и отображение надписей
\item Перехват событий клавиатуры и мыши
\item Таймеры
\item Смешивание поверхностей (накладывание надписей на основную поверхность и прочее)
\item Изменение поверхности по пикселям
\end{itemize}

\subsection{Вспомогательные библиотеки}
Также в программе используется библиотека алгоритмов и структур данных Boost, для форматирования строк, работы с датами и прочих не связанных с графикой операций.

\subsection{Хранение объектов}
Хранить объекты можно по-разному, встречалось несколько вариантов форматов и рассматривался вариант написания своего собственного.
Были рассмотрены форматы:
\begin{itemize}
\item Wavefront OBJ \\
Простой формат хранения моделей. Неиерархический, простой в чтении и записи. Поддерживает много дополнительных возможностей (например, текстуры). Удобный для чтения человеком.
\item Object File Format \\
Наиболее примитивный формат. Поддерживает самые простые свойства --- точки, нормали и полигоны. Наиболее простой из всех. Удобный для чтения человеком.
\item DirectX Model Format \\
Иерархический формат с поддержкой собственных практически произвольных свойств. Очень удобный для чтения человеком, гибкий. Средней сложности по чтению и записи.
\item COLLADA \\
Формат на XML, рекомендованный для описания моделей консорциумом Khronos Group, который также разрабатывает стандарт OpenGL. Сложный, тяжёлый в чтении и записи, так как основан на XML, плохо читаем человеком.
\item X3D \\
Ещё один формат на XML, рекомендованный для описания объектов для рендеринга в браузерах по стандарту WebGL. Схож по проблемам с COLLADA.
\end{itemize}
В итоге для хранения объектов был выбран формат DirectX Model Format (.x) из-за его сбалансированности в гибкости и простоте и хорошей читаемости человеком. Также его поддерживают множество редакторов и просмотрщиков.

\subsection{Чтение файлов}

Был выбран генератор лексических анализаторов flex и генератор парсеров bison. Они способны генерировать код для разбора файлов исходя из наборов регулярных выражений и синтаксических правил.
% TODO Дописать про парсер

\subsection{Сборка}
Проект собирался при помощи системы сборки проектов CMake. Она была выбрана из-за большой гибкости, простоты подключения и линковки сторонних библиотек и удобства и относительной простоты файлов описания процесса сборки.

\subsection{Документация}
В коде использовались комментарии в специальном формате для генерации документации Doxygen. Эта система даёт возможность построить автоматически документацию по исходному коду продукта, используя специальный формат комментариев прямо внутри кода.

\subsection{Сопроводительные записки}
Техническое задание, расчётно-пояснительная записка и прочее верстались используя систему вёрстки TeX. Это давало возможность сконцетрироваться на тексте вместо его оформления, красивую вёрстку "из коробки", множество удобных средств для оформления текста и прочее.

\end{document}