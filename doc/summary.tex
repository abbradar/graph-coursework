\documentclass[a4paper,12pt]{report}

\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{ifpdf}
\usepackage{fancyhdr}
\usepackage{hyperref}

\ifpdf
  \usepackage{cmap}
\fi

\usepackage[T2A]{fontenc}

\title{Расчётно-пояснительная записка по курсовой "Машинная графика"}
\author{Николай Амиантов}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\renewcommand{\thesection}{\arabic{section}}
\setcounter{secnumdepth}{3}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyfoot[C]{\thepage}
\fancyfoot[R]{\thedate}

\begin{document}

% TODO Поправить титульник чтобы был как по ГОСТу потом
\maketitle

\section{Введение}

Задача отрисовки трёхмерных сцен для игровых продуктов весьма актуальна в настоящее время. На рынке присутствует огромное количество игровых продуктов, существует отдельная индустрия с большим оборотом, которая удовлетворяет спрос потребителя на качественные и хорошо проработанные видеоигры. Одним из важных элементов игры является качество её графики и скорость её работы, что позволяет, с одной стороны, предложить потребителю более красивый и детальный игровой мир, а с другой --- увеличить рынок сбыта за счёт поддержки большего количества устройств. Соответственно, актуальны задачи отрисовки сложных трёхмерных сцен со множеством динамических объектов. \\
Цель работы - разработка игры--детского конструктора. В рамках данной работы я изучил алгоритмы и структуры данных, используемые в процессах отрисовки трёхмерных сцен.
% TODO Немного дополнить

\section{Аналитический раздел}
% IDEA Для каждого места где рассматриваются альтернативы сделать сначала обзор всех вариантов, а потом выбор и доводы, как в разделе про формат хранения

\subsection{Схожие продукты}
Продукт схож с играми-``песочницами'', в которых игроку предоставляется мир и правила игры, но нет чётко определённых целей и методов их достижения. Наиболее схожей с продуктом по идее (хотя гораздо сложнее) является игра Garry's Mod, которая предоставляет пользователю трёхмерный мир-карту и возможность загружать и располагать на ней любые заранее определённые объекты, менять их расположение, физические свойства, иногда размеры и внешний вид, а также соединять их друг с другом разнообразными способами. В игре реализована достаточно реалистичная физика, и основная её идея --- построение произвольных механизмов и конструкций из набора объектов. Многие идеи из неё были взяты в основу продукта, например, камера от первого лица, набор инструментов, меню для работы с объектами и прочее.

\subsection{Хранение модели}
Для модели необходимо хранить данные, описывающие его форму, а также некоторые вспомогательные величины, такие как нормали и материалы модели, и UV-координаты для текстурирования, а также её имя для идентификации внутри программы. Каждое из этих полей будет рассмотрено ниже.

\subsubsection{Форма модели}
Хранить форму модели в памяти можно хранить несколькими способами, в частности:
\begin{itemize}
\item Как наборы многоугольников с координатами точек. \\
Просто, занимает много памяти из-за повторений точек.
\item Как набор точек и многоугольники в виде наборов индексов в массиве точек. \\
Гораздо экономичнее, незначительная потеря скорости из-за необходимости разыменования, без потерь читаемости.
\end{itemize}
Был выбран второй способ как гораздо более экономичный по памяти при почти отсутствующих потерях скорости. Точки и многоугольники (наборы индексов) хранятся в раздельных массивах. Точки хранятся в ортогональном локальном базисе модели. Структура данных "массив" была выбрана, поскольку обеспечивает компактность и более быстрый обход по сравнению со связанным списком, что важно для данной задачи. С другой стороны, создание такого массива будет происходить лишь единожды, на этапе чтения объекта из файла данных, поэтому скорость добавления и удаления элементов практически не имеет значения.

\subsubsection{Многоугольники}
Можно описывать модель используя различные виды многоугольников:
\begin{itemize}
\item С динамическим количеством вершин. \\
Медленно из-за наличия динамической структуры данных.
\item С фиксированным количеством вершин. \\
Незначительно менее гибко, гораздо быстрее из-за отсутствия динамических структур данных.
\end{itemize}
Был выбран второй вид как дающий значительный прирост скорости. Потеря гибкости незначительная --- редкие модели можно представить в виде наборов многоугольников с большим количеством сторон. Более того, многие модели являются аппроксимациями реальных объектов, а при аппроксимации большое количество сторон не имеет смысла, поскольку обычно в таких моделях часто отсутствуют достаточно ровные стороны. С другой стороны, многоугольник с меньшим количеством вершин можно представить как многоугольник с большим их количеством, в котором несколько точек последовательно совпадают. \\
Также необходимо было выбрать количество сторон у многоугольников для хранения. Было выбрано хранить треугольники по следующим причинам. Во-первых, наличие многоугольников с динамическим количеством частей замедляет отрисовку и не даёт больших преимуществ кроме удобства задания модели. Во-вторых, треугольник --- самый простой из возможных многоугольников. С одной стороны, использование треугольников даёт возможность проводить некоторые специфические оптимизации, например, при отрисовке. С треугольниками легко работать, поскольку невозможно задать треугольник неверно (точки всегда будут лежать на одной плоскости). Большинство трёхмерных редакторов экспортируют модели как набор треугольников, и API видеоускорения DirectX и OpenGL работают именно с ними (и преобразовывают многоугольники в треугольники). Хотя наличие большего числа сторон может дать большую скорость отрисовки для моделей в которых сразу большие стороны представлены одним многоугольником, по моему мнению это несколько спорно из-за добавления многих нюансов, треугольники же просты и универсальны. Также, работая с треугольниками мы лишаем себя проблем по обнаружению и работе с невыпуклыми многоугольниками, что обычно требует относительно больших затрат ресурсов при отсечении, и треугольник однозначно описывает плоскость, что позволяет удобно хранить нормали к граням.

% IDEA Можно попробовать построить исследование разницы в скорости для разных видов многоугольников.

\subsubsection{Нормали}
Также для объекта необходимо хранить нормали к его вершинам и граням. Первые используются далее для расчёта освещения объекта, вторые --- для отсечения невидимых граней по положению их нормалей относительно камеры. Нормали для вершин считываются из файла (предполагается что они расчитаны заранее вручную или с помощью инструментов для трёхмерного моделирования), нормали для граней расчитываются внутри программы. Нормали для граней хранятся в массиве, причём для каждой точки под номером N её индексы в массивах точек и нормалей к вершинам будут совпадать. Нормали к граням также хранятся в массиве, причём правило совпадения индексов работает для них в совокупности с массивом многоугольников. Это возможно благодаря тому, что в программе разрешены только многоугольники с числом сторон, равным трём (треугольники), причины чего будут рассмотрены ниже. Для расчёта нормалей к граням используется простой и очевидный способ --- через векторное произведение. Все нормали хранятся в нормализованном виде, что упрощает некоторые вычисления в ходе работы программы, в частности, расчёты углов наклона нормали.

\subsubsection{Материалы}
Каждая модель может содержать в себе несколько материалов. Для каждой грани модели задаётся ссылка на её материал, причём один материал может быть использован одновременно для нескольких граней. Сам материал хранит в себе параметры для расчёта освещения грани и, возможно, указатель на текстуру для грани.

\subsubsection{UV-координаты}
UV-координаты для текстурирования хранятся в массиве, с индексами, совпадающими с индексами соответствующих точек. В массиве они хранятся нормированными в пределах $[0;1]$. Это позволяет заменять текстуру объекта ``на лету'', во время рендеринга координаты будут масштабированы чтобы совпадать с размерами текстуры. Они считываются из внешнего файла.

\subsection{Объект на сцене}
Каждая модель может быть один или несколько раз представлена на сцене. Это можно реализовать следующими способами:
\begin{itemize}
\item Копирование модели для каждого представления. \\
Медленно, занимает много памяти, неэффективно в целом.
\item Хранение дополнительной информации и указателя на общую модель. \\
Позволяет сильно экономить память и процессорное время.
\end{itemize}
По вышеупомянутым причинам для хранения объектов на сцене был выбран второй способ. Объект представлен как указатель на его модель и некоторая дополнительная информация --- его положение, оверлей материалов и кэш преобразованных точек и нормалей. Необходимость и значение этих величин будет рассмотрено ниже.

\subsubsection{Положение}
Положения в программе можно хранить:
\begin{itemize}
\item Матрицей афинного преобразования. \\
Удобно для расчётов, быстро, но плохо поддаётся изменению человеком и неудобно для хранения.
\item Смещением и эйлеровыми координатами поворота. \\
Медленнее, требует расчёта матриц преобразований, однако удобнее для изменения и хранения.
\end{itemize}
Поскольку проект предполагает частое контроллируемое человеком изменение положения объектов, был выбран второй способ. Для поворота по эйлеровым координатам существует много различных конвенций --- порядков поворота. Для проекта была выбрана конвенция X-Y-Z. (по порядку поворота)

\subsubsection{Оверлей материалов}
Необходим для изменения материала для некоторых сторон этого экземпляра модели. Из-за выбранного способа хранения объекта мы не можем напрямую изменить материал в модели, т.к. это повлечёт за собой его изменение во всех объектах, использующих эту модель. Для хранения оверлея можно было воспользоваться различными структурами данных, была выбрана структура данных ``красно-чёрное дерево''. Эта структура даёт возможность быстрого поиска объекта по ключу, что необходимо для данного её применения. Оверлей хранится как пары ``номер стороны --- замещающий материал'', и во время рендеринга производится поиск заменяющих материалов для каждой стороны модели.

\subsubsection{Кеши точек и нормалей}
Для объекта также хранятся заранее расчитанные положения его точек в глобальной системе координат, и повёрнутые соответственно объекту нормали к его сторонам. Эти вектора также хранятся в виде массива, и автоматически обновляются при изменении позиции объекта. Это сделано для увеличени скорости рендеринга, так как избавляет от необходимости выполнять некоторые преобразования каждый шаг отрисовки.

\subsection{Сцена}
Все объекты хранятся на сцене --- структуре, которая представляет собой полный набор данных для отрисовки. Она содержит в себе связанный список объектов сцены и некоторые дополнительные данные. Структура данных ``связанный список'' была выбрана т.к. предполагается частое добавление и удаление объектов со сцены, объектов на сцене на порядок меньше относительно данных всех объектов, связанный список даёт удовлетворительную скорость обхода и небольшое количество данных для поддержания структуры. \\
Были рассмотрены различные виды октодеревьев для хранения объектов. Эти структуры данных дают возможность быстро выстраивать объекты по глубине, оценивать расстояния и делать другие важные для ускорения отрисовки операции. Однако, эти структуры предполагают относительную статичность положения объектов, и при изменении координат одного объекта обычно приходится перестраивать всё дерево, что неприемлемо для нашей задачи.
% IDEA Можно подробнее изучить такие структуры данных

\subsection{Вектора и матрицы}
Для преобразований трёхмерных векторов используются матрицы и операции перемножения их между собой и умножения их на вектора. Это даёт возможность описать практически любое необходимое преобразование матрицей. Для описания различных преобразований могут быть достаточны матрицы различного размера:
\begin{itemize}
\item Линейные преобразования. \\
Преобразования вида $n_n = \sum_m a_m r_m$, где $a_m$ - некие линейные коеффициенты. Примеры таких преобразований --- повороты и масштабирования, они описываются матрицами 3x3.
\item Афинные преобразования. \\
Здесь в преобразование добавляется свободный член, что позволяет описывать также трансляции. Такие преобразования описываются матрицами 3x4.
\item Общие преобразования. \\
Такие преобразования позволяют нелинейно изменять вектора, что может потребоваться, например, для перспективного преобразования. Они требуют также работы с четырёхмерными векторами, где четвёртый член называется весом ($w$). Преобразование сводится к умножению вектора на матрицу и последующей его нормализации по $w$. Такие преобразования описываются матрицами 4x4.
\end{itemize}
Перспективное преобразование решено было реализовать отдельно, без использования матриц, поскольку в противном случае производится лишняя бесполезная операция над глубиной точки ($z$), которая также уменьшает точность последующих вычислений. Таким образом, для нужд работы оказалось достаточно афинных преобразований над векторами, поэтому используются матрицы 3x4. В процессе работы рендерера вычисляется матрица преобразования по которой все точки объекта приводятся в систему координат камеры, затем они отдельно преобразовываются согласно перспективе (удалению от наблюдателя).
% TODO Точно никак матрицей перспективное преобразование не описать?

\subsection{Отсечения}
В программе реализовано несколько этапов отсечений, что позволяет отбросить большое количество невидимых сторон перед отрисовкой и получить на выходе треугольники, ограниченные видовым прямоугольников. Рассмотрим ниже реализованные отсечения:

\subsubsection{Отсечения по направлению грани}
Простой и дешёвый способ отбросить сразу большое количество сторон путём сравнения направления их нормалей с направлением камеры пользователя.

\subsubsection{Отсечения по плоскостям}
После преобразований все треугольники отсекаются по плоскости $Z_0$ и плоскостям, ограничивающим видовой экран. Каждый треугольник обладает фиксированным числом вершин и вариантом разбиений (0, 1 или 2 треугольника в результате), причём в большинстве случаев отсечение по всем плоскостям будет целиком оставлять треугольник без изменений или отсекать его целиком (пользователь будет обычно смотреть на объект целиком). Было рассмотрено несколько вариантов реализации и выбран самый простой --- треугольники отсекаются по одному по каждой плоскости в отдельности с помощью поиска пересечений сторон треугольника с плоскостью, причём каждое отсечение может вернуть 0, 1 или 2 треугольника. Если обнаружено что треугольник не разбивался и был полностью отсечён очередной плоскостью, работа останавливается. Эта реализация, по моему мнению, самая простая и быстрая для такой задачи, поскольку у нас отсутствуют невыпуклые многоугольники и плоскости перпендикулярны координатным осям. Альтернативами являются алгоритмы отсечения многоугольников многоугольниками наподобие алгоритма Уайлера-Азертона (сложны и неоправданы для нашей задачи, а также хуже по скорости и количеству потребляемой памяти из-за общности) и, возможно, алгоритм Коэна-Сазерленда (может быть использован для отсечения по видовой рамке, но достоинства сомнительны по сравнению с отсечением по одной плоскости из-за сложности нахождения треугольника результата, т.к. алгоритм расчитан для отсечения отрезков).

\subsection{Обход треугольника и заливка}
Для обхода треугольников существует несколько возможных алгоритмов. Нас интересуют в первую очередь алгоритмы обхода векторно заданных фигур, поскольку универсальные алгоритмы (затравочный алгоритм) дают гораздо меньшую скорость обхода. Из них наиболее привлекательным по скорости является алгоритм списка активных рёбер (САР), самый быстрый из подобных алгоритмов по результатам измерений. Также его плюсом является то что установка точки на нужный цвет происходит только один раз для каждого треугольника, что оптимально для работы с z-буфером. Альтернативами являлись алгоритм с флагом, алгоритм заполнения и разнообразные его модификации.

\subsection{Отсечение невидимых поверхностей}
Для отсечения невидимых поверхностей был выбран один из самых быстрых и простых алгоритмов --- Z-буфер. С одной стороны, он обеспечивает достаточно большую скорость, причём большое время занимает заполнение буфера начальными значениями. Он занимает относительно много памяти, но это не является большим недостатком для настоящего времени --- буфер типа float (размера 4 байта) размера 640*480 занимает 1200 КиБ --- небольшой объем по сравнению с современными объёмами ОЗУ. Он также обеспечивает большую универсальность и независимость от типа и формата модели, скажем, не требует усложнения в случае невыпуклых моделей. Альтернативой является, например, алгоритм Робертса, однако он относительно сложен в реализации и скорее даёт упадок, чем прирост скорости, по сравнению с Z-буфером.

% TODO Проверить насчёт алгоритма Робертса

\subsection{Интерполяция}
Во время обхода треугольника необходимо, зная некоторые его параметры на гранях, интерполировать их значения на каждую точку из обойдённых. Существует много вариаций интерполяции, однако при предположении что все параметры изменяются по каждому из направлений обхода линейно, самым привлекательным алгоритмом становится билинейная интерполяция. Альтернативами являются, например, кубическая интерполяция, однако она даёт меньшую скорость и неточный результат. Билинейная интерполяция используется в работе для вычисления всех интерполируемых величин.

\subsection{Текстурирование}
Тексели выбираются без какой либо их интерполяции, взятием одного текселя для каждого пикселя отрисовымаемого изображения. Это связано прежде всего с необходимостью поддерживать высокую скорость расчётов для работы, так как расчёты происходят в реальном времени и включают в себя много трудоёмких вычислений вроде освещения.

Интерполяция UV-координат может быть как афинной, так и перспективной. Второй способ более трудоёмок для вычислений, но даёт лучший результат картинки. В программе для сравнения реализованы оба варианта интерполяции.

\subsection{Тонирование}
Существует несколько алгоритмов тонирования объектов:
\begin{itemize}
\item Тонирование по Гуро \\
Предполагает вычисление отсещённости на гранях объекта и интерполяцию её для сторон, включающих эти грани. Требует сравнительно меньшей вычислительной мощности, однако даёт худший результат.
\item Тонирование по Фонгу \\
Предполагает раздельное вычисление освещённости для каждего пикселя. Даёт значительно более реалистичную картинку, особенно для объектов с большими гранями, однако требует существенно б\'{о}льших вычислений.
\end{itemize}
В программе был реализован метод тонирования по Фонгу.

% TODO: Сравнить Гуро и Фонга

\subsection{Модель освещения}
Существует много различных моделей освещения, Все они отличаются реалистичностью, сложностью вычисления, моделируемыми компонентами освещения, сделанными предположениями и.т.д. Рассмотрим некоторые из них:
\begin{itemize}
\item Модель Фонга \\
Общая модель освещения. Предполагает деление света на фоновый (ambient), диффузный (diffuse) и отражённый (specular) и наличие для каждого материала коеффициентов интенсивности каждой компоненты света (поканально для каждого канала цвета, если изображение цветное) и общего коеффициента фонового цвета.
\item Модель Блинна-Фонга \\
Улучшенная модель Фонга, более сложная для вычислений, хотя выгодная для случая когда наблюдатель и источник света считаются бесконечно далёкими.
\item Модель Ламберта \\
Модель для расчёта диффузного освещения, предполагает что все грани тел отражают свет однородно по всем направлениям.
\item Модель Кука-Торренса \\
Модель для расчёта реалистичного отражённого освещения.
\end{itemize}
В программе была использована модель освещения Фонга, как общая, дающая хороший результат и умеренную вычислительную сложность и широко распостранённая.

% TODO: Исследовать различные модели освещения

\section{Конструкторский раздел}

\section{Технологический раздел}

\subsection{Технические средства}

\subsubsection{Язык программирования}
Для разработки был выбран язык программирования C++. Из его достоинств следует выделить высокую скорость (практически сравнимую с языком C для современных компиляторов) и широкие возможности, позволяющие достаточно писать достаточно удобный и выразительный код по сравнению с тем же C, а так же вероятно самое большое количество удобных сторонних библиотек на все случаи жизни. Также C++ предоставляет громоздкие но крайне эффективные методы шаблонного метапрограммирования, позволяющие генерировать очень эффективный код из неповторяющихся блоков. Из недостатков следует выделить сложность синтаксиса и большое количество правил языка и нетривиальных моментов в языке, из чего следует потенциально большое количество скрытых ошибок.

Было выбрано подмножество языка C++11, которое даёт разработчику новые возможности по написанию более быстрого и понятного кода, большие приятные нововведения в библиотеку C++ STL, а так же новые конструкции для избавления от некоторых ошибок.

В качестве альтернатив рассматривались некоторые функциональные языки программирования (Haskell, LISP), скриптовые языки общего назначения с привязками к библиотекам с машинным кодом (Python, Ruby), языки общего назначения со сборкой мусора, исполняемые на виртуальной машине (Java, Scala). Поскольку проект предполагает громоздкие вычисления с необходимостью расчётов в реальном времени, был сделан выбор в пользу компилируемых в машинный код языков программирования, среди которых был выбран C++ как наиболее удобный и функциональный, а также как один из самых быстрых.

\subsubsection{Компилятор}
В процессе разработки использовались два компилятора языка C++: GNU G++ и CLang. Первый представляет из себя самый развитый и популярный свободный компилятор для языка C++ в мире, включает в себя большое множество оптимизаций, поддерживаемых платформ и генерирует крайне эффективный код. Второй, также свободный, компилятор использовался для анализа кода, так как генерирует превосходные сообщения об ошибках и обнаруживает некоторые спорные моменты, которые ``обходит стороной'' G++. Оба компилятора были выбраны по соображениям большого количества поддерживаемых платформ, в том числе Linux, на котором в основном разрабатывался данный проект.

\subsubsection{Утилиты и среды разработки}
Проект разрабатывался в нескольких средах разработки. В основном разработка делилась на два цикла --- написание кода и отладка. Для написания кода использовался текстовый редактор Vim с набором расширений, обеспечивающих предельно комфортную работу с исходным кодом на языке C++. Для сборки и отладки использовась IDE Qt Creator, которая предоставляет удобный интерфейс к крайне функциональному и мощному отладчику GNU GDB, позволяет открывать проекты, написанные с использованием системы сборки CMake и в целом комфортна для работы. Альтернативами приведённым инструментам является редактор текстов GNU/Emacs и интерфейс отладчика GDB CGDB, предоставляющий консольный псевдроконный интерфейс для работы.

\subsubsection{Поиск ошибок}
В процессе разработки использовался свободный кроссплатформенный отладчик GNU GDB, предоставляющий широкие возможности по отслеживанию выполнения программы, поиску ошибок и изучению её работы. Также в процессе разработки использовался статический анализатор кода CppCheck, указывающий на множество незамеченных и неочевидных ошибок в исходном коде на основе его анализа. Для поиска ошибок выделения памяти использовался анализатор памяти Valgrind, результатом работы которого является список потенциальных утечек памяти, использований освобождённой памяти и других ошибок работы с ней. Для измерения скорости работы частей программы и нахождения узких мест использовался комплекс для измерения производительности Valgrind, предоставляющий табоицу функций программы со множеством статистических и временных данных.

\subsubsection{Основная библиотека}
Были рассмотрены несколько вариантов фреймворков и библиотек, на которых предполагалось осуществлять проект. В итоге, была выбрана библиотека SDL, которая предоставляет кроссплатформенный набор инструментов для создания окна, поверхности для рисования, перехват событий клавиатуры и мыши, таймеры, потоки, чтение файлов и прочее. Библиотека специально разработана для нужд программистов игр и расчитана на её применение для работы с OpenGL, но включает в себя отличные средства работы с двухмерными поверхностями в виде массивов точек с методами для слияния поверхностей, изменения и отображения. Всё это производится максимально быстро и с использованием видеокарты там где это возможно (скажем, поверхности можно смешивать аппаратно). Использованные средства:
\begin{itemize}
\item Создание и отображение окна
\item Загрузка файлов, в частности шрифтов
\item Рендеринг и отображение надписей
\item Перехват событий клавиатуры и мыши
\item Таймеры
\item Смешивание поверхностей (накладывание надписей на основную поверхность и прочее)
\item Изменение поверхности по пикселям
\end{itemize}
Существует также несколько библиотек, расширяющих SDL и добавляющих в неё новые возможности. Из них были использованы:
\begin{itemize}
\item SDL\_ttf --- для рендеринга шрифтов в программе, используется для вывода сообщений на экран.
\item SDL\_image --- для загрузки изображений в программу, используется для работы с текстурами и спрайтами.
\end{itemize}

\subsubsection{Вспомогательные библиотеки}
В программе очень активно используется стандартная библиотека шаблонов C++ STL, предоставляющая необходимые и очень оптимизированные структуры данных и алгоритмы работы с ними, ввод-вывод, функциональные объекты и прочее. Также в программе используется библиотека алгоритмов и структур данных Boost, для форматирования строк, работы с датами и прочих не связанных с графикой операций. Использованные модули из STL:
\begin{itemize}
\item vector
\item map
\item list
\item algorithm
\item memory
\item string
\item fstream
\item iostream
\item iterator
\end{itemize}
и другие. Использованные модули из набора библиотек Boost:
\begin{itemize}
\item Boost.Format
\item Boost.DateTime
\end{itemize}

\subsubsection{Матрицы и вектора}
Для сравнения в программу была добавлена возможность использовать вместо самостоятельно реализованных классов матриц и векторов стороннюю библиотеку Eigen3, предоставляющую набор шаблонных классов, эффективно собирающихся в машинный код с применением векторных инструкций процессора, что позволяет многократно ускорить работу с векторами и матрицами. Библиотека подключаема через включение соответствующего макроса при сборке проекта.

\subsubsection{Хранение объектов}
Хранить объекты можно по-разному, встречалось несколько вариантов форматов и рассматривался вариант написания своего собственного.
Были рассмотрены форматы:
\begin{itemize}
\item Wavefront OBJ \\
Простой формат хранения моделей. Неиерархический, простой в чтении и записи. Поддерживает много дополнительных возможностей (например, текстуры). Удобный для чтения человеком.
\item Object File Format \\
Наиболее примитивный формат. Поддерживает самые простые свойства --- точки, нормали и полигоны. Наиболее простой из всех. Удобный для чтения человеком.
\item DirectX Model Format \\
Иерархический формат с поддержкой собственных практически произвольных свойств. Очень удобный для чтения человеком, гибкий. Средней сложности по чтению и записи.
\item COLLADA \\
Формат на XML, рекомендованный для описания моделей консорциумом Khronos Group, который также разрабатывает стандарт OpenGL. Сложный, тяжёлый в чтении и записи, так как основан на XML, плохо читаем человеком.
\item X3D \\
Ещё один формат на XML, рекомендованный для описания объектов для рендеринга в браузерах по стандарту WebGL. Схож по проблемам с COLLADA.
\end{itemize}
В итоге для хранения объектов был выбран формат DirectX Model Format (.x) из-за его сбалансированности в гибкости и простоте и хорошей читаемости человеком. Также его поддерживают множество редакторов и просмотрщиков.

\subsubsection{Хранение сцен и настроек}
Для хранения сцен и настроек в файлах был выбран универсальный формат данных YAML. Альтернативно рассматривался XML, который, по мнению автора, является тяжело воспринимаемым человеком и громоздким форматом. В файлах формата YAML находятся все настройки программы, база моделей и сцены, которые также можно сохранять. Для парсинга и генерации файлов этого формата была использована библиотека yaml-cpp, предоставляющая набор классов для удобного чтения и создания YAML-файлов.

\subsubsection{Чтение файлов}
Был выбран генератор лексических анализаторов flex и генератор парсеров bison. Они способны генерировать код для разбора файлов исходя из наборов регулярных выражений и синтаксических правил. Была написана обёртка, позволяющая удобно работать с flex и bison из C++. На её основе был разработан полноценный универсальный парсер формата .x с поддержкой всех синтаксических конструкций формата. На выходе парсера генерируется список шаблонов и иерархическое дерево данных из файла. Парсер способен обнаруживать и указывать на ошибки в файле, подгружать шаблоны из стороннего файла и многое другое. Он был выделен в отдельную библиотеку и использован в нескольких сторонних проектах.

\subsubsection{Сборка}
Проект собирался при помощи системы сборки проектов CMake. Она была выбрана из-за большой гибкости, простоты подключения и линковки сторонних библиотек и удобства и относительной простоты файлов описания процесса сборки.

\subsubsection{Документация}
В коде использовались комментарии в специальном формате для генерации документации Doxygen. Эта система даёт возможность построить автоматически документацию по исходному коду продукта, используя специальный формат комментариев прямо внутри кода.

\subsubsection{Сопроводительные записки}
Техническое задание, расчётно-пояснительная записка и прочее верстались используя систему вёрстки \LaTeX . Это дало возможность сконцетрироваться на тексте вместо его оформления, получая красивую вёрстку ``из коробки'', множество удобных средств для оформления текста и прочее.

\section{Исследовательский раздел}
В процессе написания программы сохранялась возможность отключения и включения некоторых её оптимизаций и возможностей, на основе чего были проведены некоторые исследования, выражающиеся в замерении скорости работы программы.

\subsection{Оптимизации компилятора}
Были произведены измерения работы программы на различных уровнях оптимизации:

% Добавить график

Таким образом, уровень оптимизации -O0 крайне неэффективен для работы программи, -O1 включает некоторые базовые оптимизации, которые при приемлемом ускорении не мешают отладке программы, а -O2 и -O3 включают все возможности компилятора по оптимизациям, что даёт резкий скачок производительности.

В дальнейшем все измерения проводились на уровне оптимизации -O3, что позволяло эффективно разворачивать код, сгенерированный с помощью шаблонов и встраивать небольшие функции прямо в код вызывающей процедуры, и убирало прочие узкие но неинтересные для нас места.

\subsection{Матрицы и вектора}
Была измерена работа программы с использованием собственной библиотеки матриц и векторов по сравнению с библиотекой Eigen3, основным преимуществом которой является использование векторных инструкций процессора, что позволяло одной инструкцией выполнять аналог от нескольких до нескольких десятков обычных инструкций, сгенерированных из собственной библиотеки.

% Добавить график

Таким образом, использование векторных инструкций процессора для вычислений даёт ощутимый прирост производительности.

\section{Заключение}
В ходе разработки проекта было изучен набор алгоритмов машинной графики для отрисовки трёхмерных объектов в реальном времени, изучены новые возможности языка C++ и его подмножества C++11, изучено и применено несколько сторонних библиотек, создано несколько полезных библиотек для будущих проектов, отточены навыки программирования и использования некоторых технических средств. Итогом работы является целиком завершённая программа, а также некоторый исследовательский материал на её основе. В целом, работа выполнена успешно.

\end{document}