\documentclass[a4paper,12pt]{report}

\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{ifpdf}
\usepackage{fancyhdr}
\usepackage{minitoc}

\ifpdf
  \usepackage{cmap}
\fi

\usepackage[T2A]{fontenc}

\title{Расчётно-пояснительная записка по курсовой "Машинная графика"}
\author{Николай Амиантов}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\renewcommand{\thesection}{\arabic{section}}
\setcounter{secnumdepth}{3}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyfoot[C]{\thepage}
\fancyfoot[R]{\thedate}

\begin{document}

% Поправить титульник чтобы был как по ГОСТу потом
\maketitle

\section{Введение}

Задача отрисовки трёхмерных сцен для игровых продуктов весьма актуальна в настоящее время. На рынке присутствует огромное количество игровых продуктов, существует отдельная индустрия с большим оборотом, которая удовлетворяет спрос потребителя на качественные и хорошо проработанные видеоигры. Одним из важных элементов игры является качество её графики и скорость её работы, что позволяет, с одной стороны, предложить потребителю более красивый и детальный игровой мир, а с другой --- увеличить рынок сбыта за счёт поддержки большего количества устройств. Соответственно, актуальны задачи отрисовки сложных трёхмерных сцен со множеством динамических объектов. \\
Цель работы - разработка игры--детского конструктора. В рамках данной работы я изучил алгоритмы и структуры данных, используемые в процессах отрисовки трёхмерных сцен.
% TODO Немного дополнить

\section{Аналитический раздел}

\subsection{Схожие продукты}
Продукт схож с играми-"песочницами", в которых игроку предоставляется мир и правила игры, но нет чётко определённых целей и методов их достижения. Наиболее схожей с продуктом по идее (хотя гораздо сложнее) является игра Garry's Mod, которая предоставляет пользователю трёхмерный мир-карту и возможность загружать и располагать на ней любые заранее определённые объекты, менять их расположение, физические свойства, иногда размеры и внешний вид, а также соединять их друг с другом разнообразными способами. В игре реализована достаточно реалистичная физика, и основная её идея --- построение произвольных механизмов и конструкций из набора объектов. Многие идеи из неё были взяты в основу продукта, например, камера от первого лица, набор инструментов, меню для работы с объектами и прочее.

\subsection{Алгоритмы хранения}
Хранить объекты в памяти можно хранить несколькими способами, в частности:
\begin{itemize}
\item Как наборы многоугольников с координатами точек
\item Как набор точек и многоугольники в виде наборов индексов в массиве точек
\end{itemize}
Был выбран второй способ как гораздо более экономичный по памяти, поскольку точки в наборах многоугольников часто повторяются для соседних граней. Из его минусов --- возможно, чуть более медленная работа из-за необходимости разыменования индексов.

\subsection{Многоугольники}
Можно хранить многоугольники с фиксированным или динамическим количеством вершин. Если мы храним многоугольники с фиксированным количеством сторон, то нужно выбрать это количество. \\
Было выбрано хранить треугольники по следующим причинам. Во-первых, наличие многоугольников с динамическим количеством частей замедляет отрисовку и не даёт больших преимуществ кроме удобства задания модели. Во-вторых, треугольник --- самый простой из возможных многоугольников. С одной стороны, использование треугольников даёт возможность проводить некоторые специфические оптимизации, например, при отрисовке. С треугольниками легко работать, поскольку невозможно задать треугольник неверно (точки всегда будут лежать на одной плоскости). Большинство трёхмерных редакторов экспортируют модели как набор треугольников, и API видеоускорения DirectX и OpenGL работают именно с ними (и преобразовывают многоугольники в треугольники). Хотя наличие большего числа сторон может дать большую скорость отрисовки, по моему мнению это несколько спорно. Многие модели являются аппроксимациями реальных объектов, а при аппроксимации большое количество сторон не имеет смысла, поскольку обычно в таких моделях часто отсутствуют достаточно ровные стороны. Треугольники же просты и универсальны. Также, работая с треугольниками мы лишаем себя проблем по обнаружению и работе с невыпуклыми многоугольниками, что обычно требует относительно больших затрат ресурсов.
% IDEA Можно попробовать построить исследование разницы в скорости для разных видов многоугольников.

\subsection{Хранение в памяти}
Объект в памяти хранится как два массива --- точек и индексов. Структура данных "массив" была выбрана, поскольку обеспечивает компактность и более быстрый обход по сравнению со связанным списком, что важно для данной задачи. С другой стороны, создание такого массива будет происходить лишь единожды, на этапе чтения объекта из файла данных, поэтому скорость добавления и удаления элементов практически не имеет значения. \\
Объекты хранятся на сцене в виде связанного списка. Этот способ был выбран так как предполагается частое добавление и удаление объектов со сцены, объектов на сцене на порядок меньше относительно данных всех объектов, связанный список даёт удовлетворительную скорость обхода и небольшое количество данных для поддержания структуры. \\
Были рассмотрены различные виды октодеревьев для хранения объектов. Эти структуры данных дают возможность быстро выстраивать объекты по глубине, оценивать расстояния и делать другие важные для ускорения отрисовки операции. Однако, эти структуры предполагают относительную статичность положения объектов, и при изменении координат одного объекта обычно приходится перестраивать всё дерево, что неприемлемо для нашей задачи.
% IDEA Можно подробнее изучить такие структуры данных

\subsection{Преобразования координат}
Преобразования координат можно представить в виде операций над матрицами и векторами или операций над кватернионами. Для преобразований координат используются матрицы и операции перемножения их между собой и умножения их на вектора. Это даёт возможность описать практически любое необходимое преобразование матрицей. Исключение составило перспективное преобразование, т.к. в процессе дальшейшей отрисовки используются величины глубины каждой точки, которые оказалось невозможно сохранить при описании преобразования матрицей. В процессе работы рендерера вычисляется матрица преобразования по которой все точки объекта приводятся в систему координат камеры, затем они отдельно преобразовываются согласно перспективе (удалению от наблюдателя).
% TODO Точно никак матрицей перспективное преобразование не описать?

\subsection{Отсечение}
После преобразования все треугольники отсекаются по плоскости $Z_0$ и плоскостям, ограничивающим видовой экран. Треугольники обладают фиксированным числом вершин и вариантом разбиений (0, 1 или 2 треугольника в результате), причём в большинстве случаем отсечение по всем плоскостям будет целиком оставлять треугольник без изменений или отсекать его целиком (пользователь будет обычно смотреть на объект целиком). Было рассмотрено несколько вариантов реализации и выбран самый простой --- треугольники отсекаются по одному по каждой плоскости в отдельности с помощью поиска пересечений сторон треугольника с плоскостью, причём каждое отсечение может вернуть 0, 1 или 2 треугольника. Если обнаружено что треугольник не разбивался и был полностью отсечён очередной плоскостью, работа останавливается. Эта реализация, по моему мнению, самая простая и быстрая для такой задачи, поскольку у нас отсутствуют невыпуклые многоугольники и плоскости перпендикулярны координатным осям. Альтернативами являются алгоритмы отсечения многоугольников многоугольниками наподобие алгоритма Уайлера--Азертона (сложны и неоправданы для нашей задачи, а также хуже по скорости и количеству потребляемой памяти из-за общности) и, возможно, алгоритм Коэна--Сазерленда (может быть использован для отсечения по видовой рамке, но достоинства сомнительны по сравнению с отсечением по одной плоскости из-за сложности нахождения треугольника результата, т.к. алгоритм расчитан для отсечения отрезков).

\subsection{Отсечение невидимых поверхностей}
Для отсечения невидимых поверхностей был выбран один из самых быстрых и простых алгоритмов --- Z-буфер. С одной стороны, он обеспечивает достаточно большую скорость, причём большое время занимает заполнение буфера начальными значениями. Он занимает относительно много памяти, но это не является большим недостатком для настоящего времени --- буфер типа float размера 640*480 занимает 1200 КиБ --- небольшой объем по сравнению с современными объёмами ОЗУ. Он также обеспечивает большую универсальность и независимость от типа и формата модели, скажем, не требует усложнения в случае невыпуклых моделей. Альтернативой является, например, алгоритм Робертса, однако он относительно сложен в реализации и скорее даёт упадок, чем прирост скорости, по сравнению с Z-буфером.
% TODO Проверить насчёт алгоритма Робертса

\subsection{Заливка}
Для заливки существует несколько возможных алгоритмов. Нас интересуют в первую очередь алгоритмы заливки векторно заданных фигур, поскольку универсальные алгоритмы (затравочный алгоритм) дают гораздо меньшую скорость заливки. Из них наиболее привлекательным по скорости является алгоритм списка активных рёбер (САР), самый быстрый из подобных алгоритмов по результатам измерений. Также его плюсом является то что установка точки на нужный цвет происходит только один раз для каждого треугольника, что оптимально для работы с z-буфером. Альтернативами являлись алгоритм с флагом, алгоритм заполнения и разнообразные его модификации.

\section{Технологический раздел}

\subsection{Хранение объектов}
Хранить объекты можно по-разному, встречалось несколько вариантов форматов и рассматривался вариант написания своего собственного.
Были рассмотрены форматы:
\subsubsection*{Wavefront OBJ}
Простой формат хранения моделей. Неиерархический, простой в чтении и записи. Поддерживает много дополнительных возможностей (например, текстуры). Удобный для чтения человеком.
\subsubsection*{Object File Format}
Наиболее примитивный формат. Поддерживает самые простые свойства --- точки, нормали и полигоны. Наиболее простой из всех. Удобный для чтения человеком.
\subsubsection*{DirectX Model Format}
Иерархический формат с поддержкой собственных практически произвольных свойств. Очень удобный для чтения человеком, гибкий. Средней сложности по чтению и записи.
\subsubsection*{COLLADA}
Формат на XML, рекомендованный для описания моделей консорциумом Khronos Group, который также разрабатывает стандарт OpenGL. Сложный, тяжёлый в чтении и записи, так как основан на XML, плохо читаем человеком.
\subsubsection*{X3D}
Ещё один формат на XML, рекомендованный для описания объектов для рендеринга в браузерах по стандарту WebGL. Схож по проблемам с COLLADA.
\subsubsection*{Вывод}
Для хранения объектов был выбран формат DirectX Model Format (.x) из-за его сбалансированности в гибкости и простоте и хорошей читаемости человеком. Также его поддерживают множество редакторов и просмотрщиков.

\subsection{Чтение файлов}

Был выбран генератор лексических анализаторов flex и генератор парсеров bison. Они способны генерировать код для разбора файлов исходя из наборов регулярных выражений и синтаксических правил.

\end{document}